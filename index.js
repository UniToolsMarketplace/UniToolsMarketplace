const express = require("express");
const path = require("path");
const nodemailer = require("nodemailer");
const multer = require("multer");
require("dotenv").config();
const http = require("http");
const cloudinary = require("cloudinary").v2;

console.log("DEBUG: ENV VARS");
console.log("XATA_API_KEY:", process.env.XATA_API_KEY ? "[SET]" : "[MISSING]");
console.log("XATA_DATABASE_URL:", process.env.XATA_DATABASE_URL);

const { getXataClient } = require("./xata.client"); // generated by "npx xata init"
const xata = getXataClient();

// ---------------- CLOUDINARY SETUP ----------------
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_URL?.split("@")[1], // e.g. dbogauclq
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

// ---------------- APP SETUP ----------------
process.on("uncaughtException", (err) => {
  console.error("[UNCAUGHT EXCEPTION]", err);
});
process.on("unhandledRejection", (reason) => {
  console.error("[UNHANDLED REJECTION]", reason);
});

const app = express();
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static(path.join(__dirname, "public")));

// Multer: store files in memory (not disk)
const upload = multer({ storage: multer.memoryStorage() });

// Nodemailer
const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS,
  },
});

// OTP store
const otpStore = {};

// ---------------- UTILS: FORMAT IMAGES ----------------
async function formatImages(images) {
  if (!images) return [];
  if (Array.isArray(images)) return images;
  if (typeof images === "string") return [images];
  return [];
}

// ---------------- ROUTES ----------------
app.get("/", (req, res) => res.sendFile(path.join(__dirname, "public/index.html")));
app.get("/preowned/sell", (req, res) => res.sendFile(path.join(__dirname, "public/sell.html")));
app.get("/preowned/buy", (req, res) => res.sendFile(path.join(__dirname, "public/buy.html")));
app.get("/preowned/lease", (req, res) => res.sendFile(path.join(__dirname, "public/lease.html")));
app.get("/preowned/rent", (req, res) => res.sendFile(path.join(__dirname, "public/rent.html")));
app.get("/listing/:id", (req, res) => res.sendFile(path.join(__dirname, "public/listing.html")));
app.get("/faculties", (req, res) => res.sendFile(path.join(__dirname, "public/faculties.html")));
app.get("/dentistry", (req, res) => res.sendFile(path.join(__dirname, "public/dentistry.html")));
app.get("/preowned", (req, res) => res.sendFile(path.join(__dirname, "public/preowned.html")));

// ---------------- SELL LISTINGS WITH PAGINATION, SORT, SEARCH ----------------
app.get("/api/sell/listings", async (req, res) => {
  let { page = 1, limit = 5, sort = "none", search = "" } = req.query;
  page = parseInt(page);
  limit = parseInt(limit);

  let sortColumn = "xata.createdAt";
  let sortOrder = "desc";

  if (sort === "price_asc") {
    sortColumn = "price";
    sortOrder = "asc";
  } else if (sort === "price_desc") {
    sortColumn = "price";
    sortOrder = "desc";
  }

  let filter = { is_published: true };
  if (search && search.trim() !== "") {
    filter.item_name = { $contains: search };
  }

  const result = await xata.db.sell_listings
    .filter(filter)
    .sort(sortColumn, sortOrder)
    .getPaginated({
      pagination: { size: limit, offset: (page - 1) * limit },
    });

  const listings = await Promise.all(
    result.records.map(async (l) => ({
      ...l,
      images: await formatImages(l.images),
    }))
  );

  res.json({
    listings,
    total: result.totalCount,
    page,
    totalPages: Math.ceil(result.totalCount / limit),
  });
});

// ---------------- SELL FORM + OTP ----------------
app.post("/preowned/sell", upload.array("images"), async (req, res) => {
  const { seller_name = "", email, contact_number = "", whatsapp_number = "", item_name, item_description = "", price = "" } = req.body;

  if (!email || !email.endsWith("@bue.edu.eg")) return res.status(400).send("Email must be @bue.edu.eg domain");
  if (!item_name || !price) return res.status(400).send("Missing required fields");

  const totalSize = req.files.reduce((sum, f) => sum + f.size, 0);
  if (totalSize > 200 * 1024) return res.status(400).send("Total image size cannot exceed 200KB.");

  const otp = Math.floor(100000 + Math.random() * 900000).toString();

  // Upload images to Cloudinary
  const uploadedUrls = [];
  for (const file of req.files) {
    try {
      const result = await new Promise((resolve, reject) => {
        const stream = cloudinary.uploader.upload_stream(
          { folder: "sell_listings" },
          (err, result) => {
            if (err) reject(err);
            else resolve(result);
          }
        );
        stream.end(file.buffer);
      });
      uploadedUrls.push(result.secure_url);
    } catch (err) {
      console.error("Cloudinary upload error:", err);
    }
  }

  const record = await xata.db.sell_listings.create({
    seller_name,
    email,
    contact_number,
    whatsapp_number,
    item_name,
    item_description,
    price: parseFloat(price),
    is_published: false,
    images: uploadedUrls, // store URLs in Xata
  });

  otpStore[email] = { otp, type: "sell", recordId: record.id };

  const baseUrl = process.env.BASE_URL || `http://localhost:${port}`;
  const verifyUrl = `${baseUrl}/verify-otp/sell?email=${encodeURIComponent(email)}`;

  transporter.sendMail({
    from: process.env.EMAIL_USER,
    to: email,
    subject: "OTP for Your Sell Listing",
    html: `<p>Your OTP: <b>${otp}</b></p><p>Verify: <a href="${verifyUrl}">${verifyUrl}</a></p>`,
  });

  res.send(`<h1>OTP sent to your email!</h1><a href="${verifyUrl}">Verify here</a>`);
});

// ---------------- VERIFY OTP FOR SELL ----------------
app.get("/verify-otp/sell", (req, res) => {
  const { email } = req.query;
  if (!email || !otpStore[email]) {
    return res.status(400).send("Invalid or expired OTP session.");
  }

  res.send(`
    <h1>Verify OTP for Sell Listing</h1>
    <form method="POST" action="/verify-otp/sell">
      <input type="hidden" name="email" value="${email}" />
      <label>Enter OTP: <input type="text" name="otp" /></label>
      <button type="submit">Verify</button>
    </form>
  `);
});

app.post("/verify-otp/sell", async (req, res) => {
  const { email, otp } = req.body;
  const session = otpStore[email];

  if (!session || session.otp !== otp) {
    return res.status(400).send("Invalid OTP");
  }

  await xata.db.sell_listings.update(session.recordId, { is_published: true });
  delete otpStore[email];

  res.send("<h1>Listing verified and published!</h1><a href='/preowned/buy'>Go to Buy Page</a>");
});

// ---------------- LEASE LISTINGS ----------------
app.get("/api/lease/listings", async (req, res) => {
  let { page = 1, limit = 5, sort = "none", search = "" } = req.query;
  page = parseInt(page);
  limit = parseInt(limit);

  let sortColumn = "xata.createdAt";
  let sortOrder = "desc";

  if (sort === "price_asc") {
    sortColumn = "price";
    sortOrder = "asc";
  } else if (sort === "price_desc") {
    sortColumn = "price";
    sortOrder = "desc";
  }

  let filter = { is_published: true };
  if (search && search.trim() !== "") {
    filter.item_name = { $contains: search };
  }

  const result = await xata.db.lease_listings
    .filter(filter)
    .sort(sortColumn, sortOrder)
    .getPaginated({
      pagination: { size: limit, offset: (page - 1) * limit },
    });

  const listings = await Promise.all(
    result.records.map(async (l) => ({
      ...l,
      images: await formatImages(l.images),
    }))
  );

  res.json({
    listings,
    total: result.totalCount,
    page,
    totalPages: Math.ceil(result.totalCount / limit),
  });
});

app.get("/api/sell/listings/:id", async (req, res) => {
  const { id } = req.params;
  const record = await xata.db.sell_listings.read(id);
  if (!record || !record.is_published) return res.status(404).send("Listing not found");
  const listing = {
    ...record,
    images: await formatImages(record.images),
  };
  res.json(listing);
});

app.get("/api/lease/listings/:id", async (req, res) => {
  const { id } = req.params;
  const record = await xata.db.lease_listings.read(id);
  if (!record || !record.is_published) return res.status(404).send("Listing not found");
  const listing = {
    ...record,
    images: await formatImages(record.images),
  };
  res.json(listing);
});

// ---------------- SERVER ----------------
const port = process.env.PORT || 3000;
app.listen(port, () => console.log(`Server running on port ${port}`));